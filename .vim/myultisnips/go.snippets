###########################
# special constructs
##########################
snippet impl "type implements var _ = (*Type)(nil)"
var _ ${1:Interface}= (*${2:Type})(nil) // check interface implementation
endsnippet


snippet doc "// comment"
// ${0}
endsnippet

snippet mdoc "/* multiline comment */"
/*
${0}
*/
endsnippet

snippet sel "select" b
select
endsnippet

###########################
# error handling
##########################
snippet ferr "if err != nil { return Errorf() }"
fmt.Errorf("${1:`!v tagbar#currenttag('%s','')` error}: %v", err)
endsnippet

snippet errf "if err != nil { return Errorf() }"
if err != nil {
	return fmt.Errorf("${1:`!v tagbar#currenttag('%s','')` error}: %v", err)
}
endsnippet

snippet errf, "if err != nil { return nil, Errorf() }"
if err != nil {
	return nil, fmt.Errorf("${1:`!v tagbar#currenttag('%s','')` error}: %v", err)
}
endsnippet


# snippet errf, "if err != nil { return Errorf(),nil }"
# if err != nil {
# 	return fmt.Errorf("${1:error}: %v", err)
# }
# endsnippet

# snippet errf "if err != nil { log.Fatalln('err:', err)}"
# if err != nil {
# 	log.Fatalln("${1:Fatal} error:", err)
# }
# ${0}
# endsnippet
#
# snippet errF "if err != nil { log.Fatalf('err: %s, err)}"
# if err != nil {
# 	log.Fatalf("${1:Fatal} error: %s\n", err)
# }
# ${0}
# endsnippet

snippet tf "if err != nil { t.Fatalln('err:', err)}"
if err != nil {
	t.Fatalf("${1:Fatal} error: %s\n", err)
}
${0}
endsnippet

snippet errp "if err != nil {panic(err)}"
if err != nil {
	panic(err)
}
endsnippet

snippet errw "if err != nil {log.Print('warning')}"
if err != nil {
	log.Printf("WARN: err: %s\n", err)
}
endsnippet



###########################
# ok function and ok assertion
# (readability counts)
##########################

snippet okfun "ok function with panic"
func ok(err error) {
	if err != nil {
		panic(err)
	}
}
endsnippet

snippet okfun2 "ok function with with location"
func ok(err error) {
	if err != nil {
		pc, file, line, ok := runtime.Caller(1)
		fn := runtime.FuncForPC(pc)
		var name string
		if fn != nil {
			name = fn.Name()
		} else {
			name = file
		}
		if ok {
			log.Fatalf("ERROR [%s:%d] %s\n", name, line, err)
		}
		panic(err)
	}
}
endsnippet

snippet ok "ok function"
ok(err)
endsnippet

##############################
# v, err :=
###############################

snippet verr "v, err := code" w
${2:v}, err := ${1}
if err != nil {
	panic(err)
}
${0}
endsnippet

snippet ve "v, err := code" w
${1:v}, err := ${0}
endsnippet

###########################
# convey
##########################
snippet impc "import convey"
import (
	. "github.com/smartystreets/goconvey/convey"
)
endsnippet

snippet conv "Convey()"
Convey("${1:description}", t, func(){
	$2
})
endsnippet

snippet conv2 "internal Convey()"
Convey("${1:description}", func(){
	$2
})
endsnippet

### so with assertions

snippet so "So(Equal)"
So(${1:got}, ShouldEqual, ${2:expected})
endsnippet

snippet sone "So(NotEqual)"
So(${1:got}, ShouldNotEqual, ${2:expected})
endsnippet

snippet sogt "So(BeGreaterThan)"
So(${1:more}, ShouldBeGreaterThan, ${2:less})
endsnippet

snippet solt "So(BeLessThan)"
So(${1:less}, ShouldBeLessThan, ${2:more})
endsnippet

snippet sor "So(Resemble)"
So(${1:got}, ShouldResemble, ${2:expected})
endsnippet

snippet son "So(BeNil)"
So(${1:nil}, ShouldBeNil)
endsnippet

snippet sonn "So(NotBeNil)"
So(${1:nil}, ShouldNotBeNil)
endsnippet

snippet soe "So(err, BeNil)"
So(err, ShouldBeNil)
endsnippet

snippet soen "So(err, NotBeNil)"
So(err, ShouldNotBeNil)
endsnippet

snippet sobe "So(collection, BeEmpty)"
So(${1:collecion}, ShouldBeEmpty)
endsnippet

snippet sonbe "So(collection, NotEmpty)"
So(${1:collecion}, ShouldNotBeEmpty)
endsnippet

snippet soc "So(collection, ShouldContain, element)"
So(${1:collecion}, ShouldContain, ${2:element})
endsnippet
snippet sonc "So(collection, ShouldNotContain, element)"
So(${1:collecion}, ShouldNotContain, ${2:element})
endsnippet

###### just assertions

snippet se "ShouldEqual"
ShouldEqual
endsnippet

snippet sgt "ShouldBeGreaterThan"
ShouldBeGreaterThan
endsnippet

snippet slt "ShouldBeLessThan"
ShouldBeLessThan
endsnippet

snippet sr "ShouldResemble"
ShouldResemble
endsnippet

snippet sbe "ShouldBeEmpty"
ShouldBeEmpty
endsnippet

snippet sbne "ShouldNotBeEmpty"
ShouldNotBeEmpty
endsnippet

####### convey printing
# snippet pr- "Printf(\n---%v\n---, )"
# Printf("\n---\n%v\n---\n", ${0})
# endsnippet

# snippet pr "Printf(\n%v, )"
# Printf("\n%v", ${0})
# endsnippet

snippet pr "println"
println($0)
endsnippet

# f verbose
snippet fv "fmt.Printf( %v )"
fmt.Printf("${1:${VISUAL}} = %#v\n", $1)
endsnippet


###########################
# builtin functions
##########################
snippet ap "append"
$1 = append(${1:slice}, ${0:value})
endsnippet


##########################
# flow control
#########################

snippet br "break"
break
endsnippet

snippet cs
case ${1:value}:
	${0}
endsnippet

snippet cont "continue"
continue
endsnippet

snippet def
defer ${0:func}()
endsnippet

##########################
# keywords structs/break/continu
#########################

snippet var "var name Type"
var ${1:name} ${2:Type}
endsnippet

snippet pack "package"
package ${1:main}
${0}
endsnippet

snippet const
const ${1:NAME} = ${0:0}
endsnippet

snippet const( "const ( iota)"
const (
	${1:NAME1} = iota
	${0:NAME2}
)
endsnippet

snippet im "import"
import
endsnippet

snippet import "import ()"
import (
	"${1:package}"
)
endsnippet

# interface
snippet int "interface" i
interface
endsnippet

snippet interface "interface {}" b
interface{
	$1
}
$0
endsnippet

# snippet interface "interface {}" i
# interface{}{$1}$0
# endsnippet

snippet str "struct"
struct
endsnippet

snippet struct "struct {}"
struct{
	$1
}
$0
endsnippet

snippet init "func init() {}"
func init(){
	$1
}
$0
endsnippet

# according to: http://golang.org/pkg/go/build/
snippet build "// build +ignore"
// +build ${1:foo}

$0
endsnippet

snippet ty "type"
type $0
endsnippet

snippet re "return"
return ${1:nil}
endsnippet

###########################
# slices/channels/literals
##########################

snippet ch "channel" w
chan ${0:struct{}}
endsnippet

###########################
# builtin types
##########################
snippet bo "bool" w
bool
endsnippet

snippet by "byte" w
byte
endsnippet

snippet in "int" w
int
endsnippet

snippet i3 "int32" w
int32
endsnippet

snippet u3 "uint32" w
uint32
endsnippet

snippet i6 "int64" w
int64
endsnippet

snippet u6 "int64" w
uint64
endsnippet

snippet fa "false" w
false
endsnippet

snippet tr "true" w
true
endsnippet

snippet fl "float64" w
float64
endsnippet

snippet f3 "float32" w
float32
endsnippet

snippet f6 "float64" w
float64
endsnippet

snippet st "string" w
string
endsnippet

###############################
# testing & bench
################################

# bench function
snippet bench "func BenchmarkXYZ(t *testing.T) { ... }"
func Benchmark${1:Function}(t *testing.B) {
	${0:${VISUAL}}
}
endsnippet

##############################
# bootstarps
###############################

snippet boot "bootstrap code" w
package main

import "fmt"

func main() {
	${1}
	fmt.Println(${2:"hello world"})
}
endsnippet


snippet boottest "bootstrap testing" w
package ${1:main}

import "testing"

func Test${2:Function}(t *testing.T) {
	${0}
}
endsnippet

snippet bootbench "bootstrap bench" b
package ${1:main}

import "testing"

func Benchmark${2:Function}(t *testing.B) {
	${0}
}

endsnippet

snippet bootconv "bootstrap convey testing" w
package ${1:main}

import (
	"testing"

	. "github.com/smartystreets/goconvey/convey"
)

func TestFunction(t *testing.T) {
	Convey("description", t, func() {
		${0}
	})
}
endsnippet
